<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>晶体结构三维可视化平台</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; display: flex; height: 100vh; background-color: #1e1e1e; color: white; font-family: Arial, sans-serif; }
        #sidebar { width: 300px; padding: 20px; background-color: #252526; border-right: 1px solid #333; overflow-y: auto; }
        #viewer { flex-grow: 1; position: relative; }
        .control-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 5px; font-size: 14px; color: #ccc; }
        input, select, button { width: 100%; padding: 8px; margin-bottom: 10px; background: #333; border: 1px solid #555; color: white; border-radius: 4px; }
        button { background-color: #0e639c; cursor: pointer; font-weight: bold; }
        button:hover { background-color: #1177bb; }
        h2 { border-bottom: 1px solid #555; padding-bottom: 10px; }
    </style>
</head>
<body>

<div id="sidebar">
    <h2>晶体结构控制台</h2>

    <div class="control-group">
        <label>晶格类型</label>
        <select id="latticeType">
            <option value="BCC">体心立方 (BCC)</option>
            <option value="FCC">面心立方 (FCC)</option>
            <option value="SC">简单立方 (SC)</option>
            <option value="NaCl">岩盐结构 (NaCl)</option>
            <option value="HEX">六方晶系 (Hexagonal)</option>
        </select>
    </div>

    <div class="control-group">
        <label>晶轴长度 (a, b, c) [Å]</label>
        <div style="display: flex; gap: 5px;">
            <input type="number" id="paramA" value="5.0" step="0.1" style="width:30%">
            <input type="number" id="paramB" value="5.0" step="0.1" style="width:30%">
            <input type="number" id="paramC" value="5.0" step="0.1" style="width:30%">
        </div>
    </div>

    <div class="control-group">
        <label>晶面夹角 (α, β, γ) [°]</label>
        <input type="number" id="angleAlpha" value="90" step="1">
        <input type="number" id="angleBeta" value="90" step="1">
        <input type="number" id="angleGamma" value="90" step="1">
    </div>

    <div class="control-group">
        <label>渲染模式</label>
        <select id="renderStyle">
            <option value="ball_stick">球棍模型 (Ball-Stick)</option>
            <option value="space_filling">比例模型 (Space-Filling)</option>
        </select>
    </div>

    <div class="control-group">
        <label>导入模型 (CIF/XYZ)</label>
        <input type="file" id="fileInput" accept=".cif,.xyz" style="display:none" onchange="handleUpload(this)">
        <button onclick="document.getElementById('fileInput').click()" style="background:#27ae60;">浏览文件并导入</button>
    </div>

    <div class="control-group" style="border-top:1px solid #444; margin-top:10px; padding-top:10px;">
        <label>简易晶胞堆积 (Supercell)</label>
        <div style="display:flex; gap:5px;">
            <input type="number" id="superA" value="2" min="1" placeholder="X方向" style="width:30%">
            <input type="number" id="superB" value="2" min="1" placeholder="Y方向" style="width:30%">
            <input type="number" id="superC" value="1" min="1" placeholder="Z方向" style="width:30%">
        </div>
        <button onclick="expandSupercell()" style="background:#8e44ad; margin-top:5px;">扩展显示</button>
    </div>

    <div class="control-group" style="border-top: 1px solid #444; margin-top: 15px; padding-top: 10px;">
        <label>化学键阈值控制 (Bond Threshold)</label>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
            <span style="font-size: 12px; color: #888;">连接距离 <span id="distVal" style="color: #4CAF50; font-weight: bold;">1.6</span> Å</span>
            <button onclick="toggleBondsVisibility()" id="toggleBondBtn" style="width: auto; padding: 2px 8px; font-size: 12px; background: #555;">隐藏</button>
        </div>

        <input type="range" id="bondThreshold" min="0.5" max="3.5" step="0.1" value="1.6"
               oninput="updateThresholdLabel(this.value)"
               onchange="recalculateBondsFrontend()">

        <p style="font-size: 11px; color: #666; margin: 0;">
            提示：石墨层内请设为 1.5-1.6，金属氧化物请设为 2.0+
        </p>
    </div>

    <button onclick="generateModel()" style="background: #28a745;">生成并更新模型</button>
    <button onclick="resetCamera()" style="background: #555; margin-top: 10px;">重置视角</button>
    <button onclick="toggleAnimation()" id="animBtn" style="background: #e67e22;">开启热振动模拟</button>
    <button onclick="downloadXYZ()" style="background: #6f42c1; margin-top: 10px;">导出 XYZ 文件</button>
    <div class="control-group" style="margin-top: 30px; border-top: 1px solid #444; padding-top: 20px;">
        <h3>结构属性编辑</h3>
        <div id="atomTableContainer" style="max-height: 300px; overflow-y: auto; background: #1a1a1a; padding: 5px;">
            <table style="width: 100%; font-size: 12px; border-collapse: collapse;" id="atomTable">
                <thead>
                <tr style="color: #888; border-bottom: 1px solid #333;">
                    <th>元素</th>
                    <th>X</th>
                    <th>Y</th>
                    <th>Z</th>
                    <th>操作</th>
                </tr>
                </thead>
                <tbody id="atomListBody">
                </tbody>
            </table>
        </div>
        <button onclick="applyPropertyChanges()" style="background: #f1c40f; color: #000; margin-top: 10px; font-weight: bold;">应用修改</button>
    </div>
    <div id="errorConsole" style="color: #ff4d4d; font-size: 12px; margin-top: 15px; font-weight: bold;"></div>
</div>

<div id="viewer"></div>

<script>
    // --- 1. 全局变量声明 (必须放在最前面) ---
    let atomMeshes = [];
    let bondMeshes = [];
    let isAnimating = false;

    // --- 2. Three.js 初始化 ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1e1e1e);

    const viewer = document.getElementById('viewer');
    const camera = new THREE.PerspectiveCamera(45, viewer.clientWidth / viewer.clientHeight, 0.1, 1000);
    camera.position.set(10, 10, 20);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(viewer.clientWidth, viewer.clientHeight);
    viewer.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // 灯光设置
    const ambientLight = new THREE.AmbientLight(0x404040, 2);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(10, 10, 10);
    scene.add(directionalLight);

    const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
    scene.add(gridHelper);


    const elementConfig = {
        "Fe": { color: "#FF0000", radius: 0.6 },
        "Cu": { color: "#FFA500", radius: 0.6 },
        "Al": { color: "#0000FF", radius: 0.7 },
        "Cl": { color: "#00FF00", radius: 0.5 },
        "Na": { color: "#800080", radius: 0.8 },
        "O":  { color: "#FF4500", radius: 0.4 },
        "C":  { color: "#444444", radius: 0.4 },
        "H":  { color: "#FFFFFF", radius: 0.3 }
    };

    // 【新增】 监听晶格类型切换，自动重置参数
    // 解决“导入石墨后切回BCC导致模型崩坏”的问题
    document.getElementById('latticeType').addEventListener('change', function() {
        // 当用户手动切换晶格类型时，认为他想看一个新的标准模型
        // 因此我们将参数重置为默认值，清除之前导入文件留下的“脏数据”
        document.getElementById('paramA').value = "5.0";
        document.getElementById('paramB').value = "5.0";
        document.getElementById('paramC').value = "5.0";
        document.getElementById('angleAlpha').value = "90";
        document.getElementById('angleBeta').value = "90";
        document.getElementById('angleGamma').value = "90";

        // 可选：直接触发一次生成，让用户立即看到新模型
        // generateModel();
    });

    // --- 3. 核心功能函数 ---


    // 【新增】更新滑动条数值显示
    function updateThresholdLabel(val) {
        document.getElementById('distVal').innerText = val;
    }

    // 【新增】纯前端计算化学键（核心逻辑）
    function recalculateBondsFrontend() {
        const threshold = parseFloat(document.getElementById('bondThreshold').value);

        // 1. 清除旧的键
        bondMeshes.forEach(mesh => scene.remove(mesh));
        bondMeshes = [];

        // 如果当前被设为隐藏，或者不是球棍模型，则不计算
        const style = document.getElementById('renderStyle').value;
        if (style !== 'ball_stick') return;

        // 2. 遍历所有原子，计算距离
        // 注意：这里是 O(N^2) 复杂度，对于 <1000 个原子很流畅。
        // 如果原子数上万，需要优化算法（如八叉树），但晶体学场景通常不用。
        for (let i = 0; i < currentAtomData.length; i++) {
            for (let j = i + 1; j < currentAtomData.length; j++) {
                const atomA = currentAtomData[i];
                const atomB = currentAtomData[j];

                // 计算欧几里得距离
                const dx = atomA.x - atomB.x;
                const dy = atomA.y - atomB.y;
                const dz = atomA.z - atomB.z;
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

                // 3. 判定逻辑：
                // 大于 0.1 (避免重叠点报错) 且 小于 用户设定的阈值
                if (dist > 0.1 && dist <= threshold) {
                    renderBond(atomA, atomB);
                }
            }
        }

        console.log(`前端重算完成：阈值 ${threshold} Å, 生成了 ${bondMeshes.length} 条键`);
    }

    // 【新增】快速切换键的显示/隐藏
    function toggleBondsVisibility() {
        const btn = document.getElementById('toggleBondBtn');
        const isHidden = btn.innerText === "显示";

        if (isHidden) {
            // 也就是当前是隐藏状态，点击后要显示
            btn.innerText = "隐藏";
            btn.style.background = "#555";
            recalculateBondsFrontend(); // 重新计算并显示
        } else {
            // 当前是显示状态，点击后要隐藏
            btn.innerText = "显示";
            btn.style.background = "#d35400";
            // 清除所有键
            bondMeshes.forEach(mesh => scene.remove(mesh));
            bondMeshes = [];
        }
    }

    function expandSupercell() {
        // 1. 获取基础参数
        const nx = parseInt(document.getElementById('superA').value) || 1;
        const ny = parseInt(document.getElementById('superB').value) || 1;
        const nz = parseInt(document.getElementById('superC').value) || 1;

        const a = parseFloat(document.getElementById('paramA').value);
        const b = parseFloat(document.getElementById('paramB').value);
        const c = parseFloat(document.getElementById('paramC').value);

        // 2. 获取当前表格中的原始原子（作为基元）
        const baseAtoms = [];
        document.querySelectorAll('#atomListBody tr').forEach(row => {
            const inputs = row.querySelectorAll('input');
            // 获取该行原子的颜色（从之前渲染的 Mesh 或预设中获取）
            // 如果你的表格里没存颜色，我们直接根据元素名匹配
            const element = inputs[0].value;
            baseAtoms.push({
                element: element,
                x: parseFloat(inputs[1].value),
                y: parseFloat(inputs[2].value),
                z: parseFloat(inputs[3].value),
                // 根据元素名动态获取颜色（兼容你后端的配色逻辑）
                color: getElementColor(element)
            });
        });

        if (baseAtoms.length === 0) {
            alert("请先生成或导入基础模型！");
            return;
        }

        // 3. 构建超晶胞原子阵列
        let expandedAtoms = [];
        for (let i = 0; i < nx; i++) {
            for (let j = 0; j < ny; j++) {
                for (let k = 0; k < nz; k++) {
                    baseAtoms.forEach(atom => {
                        expandedAtoms.push({
                            ...atom,
                            // 计算平移后的坐标
                            x: atom.x + (i * a),
                            y: atom.y + (j * b),
                            z: atom.z + (k * c)
                        });
                    });
                }
            }
        }

        // 4. 调用统一的渲染逻辑
        // 构造一个临时的 data 对象传给 renderData
        const supercellData = {
            atoms: expandedAtoms,
            // 这里要把总的范围传过去，以便 renderData 画出大的边框
            a: a * nx,
            b: b * ny,
            c: c * nz
        };

        renderData(supercellData);

        // 5. 调整相机，让视角包围整个超晶胞
        const centerX = (a * nx) / 2;
        const centerY = (b * ny) / 2;
        const centerZ = (c * nz) / 2;
        controls.target.set(centerX, centerY, centerZ);
        camera.position.set(centerX + a*nx, centerY + b*ny, centerZ + c*nz);
        controls.update();

        alert(`超晶胞生成成功：包含 ${expandedAtoms.length} 个原子`);
    }

    // 辅助函数：根据元素获取颜色（确保和后端一致）
    function getElementColor(element) {
        const colors = {
            'C': '#808080',   // 灰色
            'O': '#ff4d4d',   // 红色
            'Fe': '#e67e22',  // 橙色/铁锈色
            'Na': '#3498db',  // 蓝色
            'Cl': '#2ecc71',  // 绿色
            'H': '#ffffff' ,   // 白色
            'N': '#3050f8',
        };
        return colors[element.toUpperCase()] || '#cccccc';
    }

    // 清理场景
    function clearScene() {
        atomMeshes.forEach(m => scene.remove(m));
        bondMeshes.forEach(m => scene.remove(m));
        atomMeshes = [];
        bondMeshes = [];
    }

    // 渲染化学键 (棍子)
    function renderBond(start, end) {
        const startVec = new THREE.Vector3(start.x, start.y, start.z);
        const endVec = new THREE.Vector3(end.x, end.y, end.z);
        const distance = startVec.distanceTo(endVec);

        const geometry = new THREE.CylinderGeometry(0.1, 0.1, distance, 8);
        const material = new THREE.MeshPhongMaterial({ color: 0xcccccc });
        const cylinder = new THREE.Mesh(geometry, material);

        // 计算位置：两点中点
        const midpoint = new THREE.Vector3().addVectors(startVec, endVec).multiplyScalar(0.5);
        cylinder.position.copy(midpoint);

        // 计算旋转：朝向目标
        const direction = new THREE.Vector3().subVectors(endVec, startVec).normalize();
        const axis = new THREE.Vector3(0, 1, 0); // 圆柱体默认朝上
        cylinder.quaternion.setFromUnitVectors(axis, direction);

        scene.add(cylinder);
        bondMeshes.push(cylinder);
    }

    // [关键修复] 控制键的显示/隐藏
    function hideBonds(isHidden) {
        bondMeshes.forEach(mesh => {
            mesh.visible = !isHidden;
        });
    }

    // 生成模型的主逻辑
    function generateModel() {
        const consoleDiv = document.getElementById('errorConsole');
        consoleDiv.innerText = "";

        const req = {
            latticeType: document.getElementById('latticeType').value,
            a: parseFloat(document.getElementById('paramA').value),
            b: parseFloat(document.getElementById('paramB').value),
            c: parseFloat(document.getElementById('paramC').value),
            alpha: parseFloat(document.getElementById('angleAlpha').value),
            beta: parseFloat(document.getElementById('angleBeta').value),
            gamma: parseFloat(document.getElementById('angleGamma').value)
        };

        fetch('/api/crystal/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(req)
        })
            .then(response => response.json())
            .then(data => {
                clearScene(); // 先清理旧模型
                const style = document.getElementById('renderStyle').value;

                // 1. 渲染原子
                if (data.atoms) {
                    data.atoms.forEach(atom => {
                        // 根据模式决定半径
                        const radiusScale = (style === 'space_filling') ? 1.0 : 0.3;
                        const displayRadius = atom.radius * radiusScale;

                        const geometry = new THREE.SphereGeometry(displayRadius, 32, 32);
                        const material = new THREE.MeshPhongMaterial({ color: atom.color });
                        const sphere = new THREE.Mesh(geometry, material);
                        sphere.position.set(atom.x, atom.y, atom.z);

                        scene.add(sphere);
                        atomMeshes.push(sphere);
                    });
                    updateAtomTable(data.atoms);
                }

                // 2. 渲染化学键 (仅在球棍模式下计算并显示)
                if (style === 'ball_stick' && data.bonds) {
                    data.bonds.forEach(bond => renderBond(bond.start, bond.end));
                    // 3. 绘制晶胞边框
                    const a = req.a, b = req.b, c = req.c;
                    const boxGeom = new THREE.BoxGeometry(a, b, c);
                    const edges = new THREE.EdgesGeometry(boxGeom);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 }));

                    // 将边框对齐到原点起始位置（因为Three.js Box默认中心在0,0,0）
                    line.position.set(a/2, b/2, c/2);
                    scene.add(line);
                    bondMeshes.push(line); // 放入此数组是为了下次点生成时能被 clearScene() 清理掉

                    // 4. 显示后端传回的错误/警告信息
                    const consoleDiv = document.getElementById('errorConsole');
                    if (data.atoms && data.atoms.length > 0) {
                        // 重新获取一下警告（如果有重叠原子等）
                        fetch('/api/crystal/generate', { /* 这里逻辑其实已经包含在data里了 */});
                        // 直接显示
                        if (data.errors && data.errors.length > 0) {
                            consoleDiv.style.color = "#ffae00";
                            consoleDiv.innerText = "警告：\n" + data.errors.join("\n");
                        }
                    }
                } else {
                    // 如果是空间填充模式，确保没有残留的键显示（虽然clearScene已处理，但保持逻辑严谨）
                    hideBonds(true);
                }
                updateAtomTable(data.atoms);
                console.log(`渲染完成：${data.atoms.length}个原子, ${data.bonds ? data.bonds.length : 0}条键`);

                if(data.errors && data.errors.length > 0) {
                    consoleDiv.innerText = data.errors.join("\n");
                }
            })
            .catch(err => {
                console.error("生成失败:", err);
                consoleDiv.innerText = "请求失败，请检查后端服务是否启动。";
            });
    }

    // 导出功能
    async function downloadXYZ() {
        console.log("开始导出..."); // 调试日志

        try {
            // 1. 获取基础参数 (检查 ID 是否匹配)
            const getVal = (id) => parseFloat(document.getElementById(id).value) || 0;

            const req = {
                latticeType: document.getElementById('latticeType').value,
                a: getVal('paramA'),
                b: getVal('paramB'),
                c: getVal('paramC'),
                alpha: getVal('angleAlpha'),
                beta: getVal('angleBeta'),
                gamma: getVal('angleGamma'),
                // 2. [修复] 直接在这里获取表格里的原子数据
                customAtoms: Array.from(document.querySelectorAll('#atomListBody tr')).map(row => {
                    const inputs = row.querySelectorAll('input');
                    return {
                        element: inputs[0].value,
                        x: parseFloat(inputs[1].value) || 0,
                        y: parseFloat(inputs[2].value) || 0,
                        z: parseFloat(inputs[3].value) || 0,
                        color: "#808080", // 给个默认灰色
                        radius: 1.0       // 给个默认半径
                    };
                })
            };

            console.log("发送请求数据:", req);

            // 3. 发送请求
            const response = await fetch('/api/crystal/export', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(req)
            });

            if (!response.ok) throw new Error("后端响应失败: " + response.status);
            const text = await response.text();

            // 4. 弹出保存对话框 (现代浏览器方案)
            if ('showSaveFilePicker' in window) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: 'crystal_structure.xyz',
                        types: [{
                            description: 'XYZ Files',
                            accept: { 'text/plain': ['.xyz'] },
                        }],
                    });
                    const writable = await handle.createWritable();
                    await writable.write(text);
                    await writable.close();
                    console.log("保存成功");
                } catch (userCancel) {
                    console.log("用户取消了保存");
                }
            } else {
                // 5. 兼容旧版浏览器的下载方案
                const blob = new Blob([text], { type: 'text/plain' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = "crystal_structure.xyz";
                a.click();
                window.URL.revokeObjectURL(url);
            }

        } catch (err) {
            console.error("导出过程出错:", err);
            alert("导出失败: " + err.message);
        }
    }

    // 1. 刷新表格内容
    function updateAtomTable(atoms) {
        const tbody = document.getElementById('atomListBody');
        tbody.innerHTML = ""; // 清空旧行

        atoms.forEach((atom, index) => {
            const row = document.createElement('tr');
            row.style.borderBottom = "1px solid #333";
            row.innerHTML = `
            <td><input type="text" value="${atom.element}" class="edit-el" style="width:25px; background:none; color:white; border:none;"></td>
            <td><input type="number" step="0.1" value="${atom.x.toFixed(2)}" class="edit-x" style="width:40px; background:#333; color:white;"></td>
            <td><input type="number" step="0.1" value="${atom.y.toFixed(2)}" class="edit-y" style="width:40px; background:#333; color:white;"></td>
            <td><input type="number" step="0.1" value="${atom.z.toFixed(2)}" class="edit-z" style="width:40px; background:#333; color:white;"></td>
            <td><button onclick="this.parentElement.parentElement.remove()" style="background:red; padding:2px 5px;">删</button></td>
        `;
            tbody.appendChild(row);
        });
    }

    // 2. 应用修改（手册要求的编辑保存功能）
    function applyPropertyChanges() {
        // 1. [检查点] 确保你的 HTML 表格 body 的 ID 是 atomListBody 还是 atom-list
        const rows = document.querySelectorAll('#atomListBody tr');
        const atomsData = [];

        rows.forEach(row => {
            const elInput = row.querySelector('.edit-el');
            if (!elInput) return;

            const el = elInput.value;
            // 使用 parseFloat 时，确保能取到值，否则默认为 0
            const x = parseFloat(row.querySelector('.edit-x').value) || 0.0;
            const y = parseFloat(row.querySelector('.edit-y').value) || 0.0;
            const z = parseFloat(row.querySelector('.edit-z').value) || 0.0;

            if (el) {
                atomsData.push({
                    element: el,
                    x: x,
                    y: y,
                    z: z,
                    color: "#808080", // 这里的颜色后端会根据 assignAtomProperties 重新分配，填默认即可
                    radius: 1.0
                });
            }
        });

        // 2. 构造请求体
        const req = {
            latticeType: document.getElementById('latticeType').value,
            // [检查点] 确保 ID 和 HTML 对应：是 paramA 还是 a？
            a: parseFloat(document.getElementById('paramA').value) || 1.0,
            b: parseFloat(document.getElementById('paramB').value) || 1.0,
            c: parseFloat(document.getElementById('paramC').value) || 1.0,
            alpha: parseFloat(document.getElementById('angleAlpha').value) || 90,
            beta: parseFloat(document.getElementById('angleBeta').value) || 90,
            gamma: parseFloat(document.getElementById('angleGamma').value) || 90,
            customAtoms: atomsData
        };

        // 3. 发送请求
        // [注意] 这里你用的是 /api/crystal/generate
        // 请确保后端 CrystalService.generateStructure 逻辑里有：
        // "如果 customAtoms 不为空，则直接用 customAtoms，不再生成默认晶格"
        fetch('/api/crystal/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(req)
        })
            .then(res => {
                if (!res.ok) throw new Error("后端服务异常: " + res.status);
                return res.json();
            })
            .then(data => {
                // 渲染 3D 场景
                renderData(data);

                // [修正] 确保你有这个函数，否则会报错中断
                if (typeof updateAtomTable === 'function') {
                    updateAtomTable(data.atoms);
                }

                alert("同步成功，化学键已重新计算！");
            })
            .catch(err => {
                console.error("同步出错:", err);
                alert("同步失败：" + err.message);
            });
    }
    // 补充一个全场景渲染函数，确保边框不消失
    function renderData(data) {
        clearScene(); // 清空旧模型
        currentAtomData = data.atoms || [];
        const style = document.getElementById('renderStyle').value;

        // --- 1. 画原子 (保持之前的代码) ---
        currentAtomData.forEach(atom => {
            const radiusScale = (style === 'space_filling') ? 1.0 : 0.3;
            const geometry = new THREE.SphereGeometry((atom.radius || 0.5) * radiusScale, 32, 32);
            const material = new THREE.MeshPhongMaterial({ color: atom.color || "#808080" });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(atom.x, atom.y, atom.z);
            scene.add(sphere);
            atomMeshes.push(sphere);
        });

        // --- 2. 画化学键 (调用之前写好的前端计算) ---
        if (style === 'ball_stick') {
            recalculateBondsFrontend();
        }

        // --- 3. 核心修复：画晶胞边框 ---
        // 无论 data.a 是原始值还是扩展后的值，我们都创建一个透明立方体来承载边框
        if (data.a && data.b && data.c) {
            // 创建一个对应大小的透明盒子
            const boxGeom = new THREE.BoxGeometry(data.a, data.b, data.c);
            const boxMat = new THREE.MeshBasicMaterial({ visible: false }); // 不可见
            const boxMesh = new THREE.Mesh(boxGeom, boxMat);

            // 关键点：设置盒子的位置。
            // Three.js 的 BoxGeometry 默认中心在 (0,0,0)，而原子坐标通常是从 (0,0,0) 开始增长的
            // 所以盒子中心要偏移到 (a/2, b/2, c/2)
            boxMesh.position.set(data.a / 2, data.b / 2, data.c / 2);
            scene.add(boxMesh);

            // 使用 BoxHelper 包裹这个盒子，生成绿色的边框线
            const helper = new THREE.BoxHelper(boxMesh, 0x00ff00); // 绿色
            scene.add(helper);

            // 将边框对象存入 bondMeshes 数组，方便以后清理
            bondMeshes.push(boxMesh);
            bondMeshes.push(helper);
        }
    }
    // [核心修复] 重新构建整个场景（含原子、键、边框）
    function rebuildScene(atoms) {
        clearScene(); // 清空旧模型

        const style = document.getElementById('renderStyle').value;

        // 1. 绘制原子
        atoms.forEach(atom => {
            const radiusScale = (style === 'space_filling') ? 1.0 : 0.3;
            const geometry = new THREE.SphereGeometry(atom.radius * radiusScale, 32, 32);
            const material = new THREE.MeshPhongMaterial({ color: atom.color });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(atom.x, atom.y, atom.z);
            scene.add(sphere);
            atomMeshes.push(sphere); // 存入数组方便下次清理
        });

        // 2. 绘制晶胞边框 (从输入框实时获取 a, b, c)
        const a = parseFloat(document.getElementById('paramA').value) || 1;
        const b = parseFloat(document.getElementById('paramB').value) || 1;
        const c = parseFloat(document.getElementById('paramC').value) || 1;

        const boxGeom = new THREE.BoxGeometry(a, b, c);
        const edges = new THREE.EdgesGeometry(boxGeom);
        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 }));
        line.position.set(a/2, b/2, c/2);
        scene.add(line);
        bondMeshes.push(line); // 存入 bondMeshes 数组统一管理

        // 3. 绘制化学键 (只有球棍模式下绘制)
        if (style === 'ball_stick') {
            for (let i = 0; i < atoms.length; i++) {
                for (let j = i + 1; j < atoms.length; j++) {
                    const dist = Math.sqrt(
                        Math.pow(atoms[i].x - atoms[j].x, 2) +
                        Math.pow(atoms[i].y - atoms[j].y, 2) +
                        Math.pow(atoms[i].z - atoms[j].z, 2)
                    );
                    // 判定连线距离（1.0 到 3.5 埃之间）
                    if (dist > 1.0 && dist < 3.5) {
                        renderBond(atoms[i], atoms[j]);
                    }
                }
            }
        }
        console.log("模型、边框与化学键已重新加载");
    }
    // 辅助函数：不经过后端生成，直接渲染已有数据
    function renderFromLocalData(atoms) {
        clearScene();
        const style = document.getElementById('renderStyle').value;

        // 渲染修改后的原子
        atoms.forEach(atom => {
            const geometry = new THREE.SphereGeometry(atom.radius, 32, 32);
            const material = new THREE.MeshPhongMaterial({ color: "#00ff00" }); // 简化处理
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.set(atom.x, atom.y, atom.z);
            scene.add(sphere);
            atomMeshes.push(sphere);
        });

        // 注意：化学键需要后端重新计算距离，如果需要连线，建议把 updatedAtoms 发回后端 api/crystal/calculateBonds
        console.log("属性已更新");
    }

    function resetCamera() {
        camera.position.set(10, 10, 20);
        camera.lookAt(0, 0, 0);
        controls.reset();
    }

    // 动画切换
    function toggleAnimation() {
        isAnimating = !isAnimating;
        const btn = document.getElementById('animBtn');
        btn.innerText = isAnimating ? "停止动画" : "开启热振动模拟";
        btn.style.background = isAnimating ? "#d35400" : "#e67e22";
    }
    // 处理文件上传
    function handleUpload(input) {
        const file = input.files[0];
        if (!file) return;

        // 清空 input 值，这样同一个文件选两次也能触发 change 事件
        input.value = '';

        const formData = new FormData();
        formData.append("file", file);

        const loadingBtn = document.querySelector('button[onclick*="fileInput"]');
        const originalText = loadingBtn.innerText;
        loadingBtn.innerText = "正在解析...";

        fetch('/api/crystal/import', {
            method: 'POST',
            body: formData
        })
            .then(res => {
                if (!res.ok) throw new Error("Status: " + res.status);
                return res.json();
            })
            .then(data => {
                console.log("Parsed Data:", data);

                // 1. 更新输入框 (使用 || 保护防止 null)
                document.getElementById('latticeType').value = "HEX"; // CIF 导入通常是非标准类型，或者根据 gamma 判断
                document.getElementById('paramA').value = (data.a || 5.0).toFixed(4);
                document.getElementById('paramB').value = (data.b || 5.0).toFixed(4);
                document.getElementById('paramC').value = (data.c || 5.0).toFixed(4);
                document.getElementById('angleAlpha').value = (data.alpha || 90).toFixed(2);
                document.getElementById('angleBeta').value = (data.beta || 90).toFixed(2);
                document.getElementById('angleGamma').value = (data.gamma || 90).toFixed(2);

                // 2. 更新原子列表
                updateAtomTable(data.atoms || []);

                // 3. 渲染场景
                // 注意：CIF 只有不对称单元，我们可能需要提醒用户
                if (data.atoms && data.atoms.length < 2) {
                    alert("导入成功！\n注意：此 CIF 文件仅包含不对称单元（" + data.atoms.length + " 个原子）。\n真实的晶体结构需要应用空间群对称操作，当前简易版暂未支持自动扩展。");
                }

                renderData(data); // 使用你代码里定义的 renderData

                // 4. 重置相机看中心
                if (data.atoms && data.atoms.length > 0) {
                    // 计算简单的中心点
                    let cx = 0, cy = 0, cz = 0;
                    data.atoms.forEach(a => { cx += a.x; cy += a.y; cz += a.z; });
                    cx /= data.atoms.length;
                    cy /= data.atoms.length;
                    cz /= data.atoms.length;

                    controls.target.set(cx, cy, cz);
                    camera.position.set(cx + 10, cy + 10, cz + 10);
                    controls.update();
                }
            })
            .catch(err => {
                console.error(err);
                alert("导入失败: " + err.message + "\n可能是 CIF 格式不兼容");
            })
            .finally(() => {
                loadingBtn.innerText = originalText;
            });
    }

    // 窗口自适应
    window.addEventListener('resize', onWindowResize, false);
    function onWindowResize() {
        const box = document.getElementById('viewer');
        camera.aspect = box.clientWidth / box.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(box.clientWidth, box.clientHeight);
    }

    // 渲染循环
    function animate() {
        requestAnimationFrame(animate);
        if (isAnimating) {
            atomMeshes.forEach(mesh => {
                mesh.position.x += (Math.random() - 0.5) * 0.05;
                mesh.position.y += (Math.random() - 0.5) * 0.05;
                mesh.position.z += (Math.random() - 0.5) * 0.05;
            });
        }
        controls.update();
        renderer.render(scene, camera);
    }

    // 启动
    animate();
    // 页面加载后自动生成一次
    window.onload = generateModel;

</script>
</body>
</html>